# Migration Summary: Security & Performance Hardening

**File:** `supabase/migrations/20250214000000_security_performance_fixes.sql`
**Date:** 2025-02-14
**Resolves:** 32 security issues + performance index gaps (112 total Supabase advisor issues)

---

## Security Fixes (32 issues)

### 1. Missing RLS (1 issue)

| Table | Fix |
|-------|-----|
| `voice_clones` | `ALTER TABLE ... ENABLE ROW LEVEL SECURITY` |

The `voice_clones` table was created in migration `20250212000000` without enabling RLS. This migration enables it and adds proper policies.

### 2. Security Definer View (1 issue)

| View | Fix |
|------|-----|
| `video_embeddings` | Recreated with `security_invoker = true` |

The view was implicitly `SECURITY DEFINER`, meaning it executes with the view owner's permissions regardless of who queries it. Changed to `SECURITY INVOKER` so the calling role's permissions apply.

### 3. Mutable search_path Functions (4 issues)

| Function | Fix |
|----------|-----|
| `public.nanoid()` | Added `SET search_path = ''` + explicit `public.` schema refs |
| `public.build_context_block()` | Added `SET search_path = ''` + explicit `public.` schema refs |
| `public.get_prerequisite_chain()` | Added `SET search_path = ''` + explicit `public.` schema refs |
| `public.get_learning_path()` | Added `SET search_path = ''` + explicit `public.` schema refs |

Without a fixed search_path, an attacker who can manipulate the search_path could inject malicious schema objects that shadow standard functions/tables. Setting `search_path = ''` and using fully-qualified table names (`public.video_knowledge` instead of `video_knowledge`) prevents this.

### 4. Extensions in Public Schema (2 issues)

| Extension | Fix |
|-----------|-----|
| `pg_trgm` | Moved to `extensions` schema via `ALTER EXTENSION ... SET SCHEMA` |
| `vector` | Moved to `extensions` schema via `ALTER EXTENSION ... SET SCHEMA` |

Supabase best practice is to keep extensions in the `extensions` schema. The `config.toml` already includes `extensions` in `extra_search_path`, so operators and functions will continue to resolve. We use `ALTER EXTENSION SET SCHEMA` (not drop+recreate) to preserve existing indexes and columns that depend on these extensions.

Both moves are wrapped in `DO $$ ... EXCEPTION WHEN OTHERS` blocks for safety. If the extension is already in the target schema, the operation is skipped.

### 5. Overly Permissive RLS Policies (26 issues across 24 tables)

**Before:** All tables had `FOR ALL USING (true) WITH CHECK (true)` policies, allowing anyone (including anonymous browser clients) to read, insert, update, and delete any row.

**After:** Each table gets granular per-operation policies:

| Policy Pattern | SELECT | INSERT | UPDATE | DELETE |
|----------------|--------|--------|--------|--------|
| **Standard (22 tables)** | `USING (true)` | `current_setting('role') = 'service_role'` | `current_setting('role') = 'service_role'` | `current_setting('role') = 'service_role'` |
| **conversations (1 table)** | `USING (true)` | `WITH CHECK (true)` | `USING (true)` | `USING (true)` |
| **visualizations (1 table)** | `USING (true)` | `current_setting('role') = 'service_role'` | `current_setting('role') = 'service_role'` | `current_setting('role') = 'service_role'` |

**Why conversations allows anon writes:** The `lib/conversations.ts` module writes to the `conversations` table directly from the browser using the Supabase anon key. This is a math visualizer chat history feature. Until this is refactored to use a server-side API route, anon writes must remain open. Conversations contain no sensitive data and have no auth context.

**Why visualizations is service-role-only for writes:** The `lib/supabase.ts` `saveVisualization()` function uses `getWriteClient()` which prefers the service role key, so browser-side inserts already go through the server.

**Tables with service-role-only writes (22):**
- `video_sessions`, `shared_notes`, `study_collections`, `video_analytics`
- `video_bookmarks`, `study_flashcards`, `video_notes`, `transcripts`
- `visualizations`, `voice_clones`, `channels`, `video_knowledge`
- `concepts`, `concept_relations`, `concept_mentions`, `video_chapters`
- `video_moments`, `quiz_questions`, `external_references`, `cross_video_links`
- `enriched_transcripts`, `batch_progress`, `knowledge_embeddings`

---

## Performance Fixes

### 6. New Indexes (11 indexes)

| Index | Table | Columns | Rationale |
|-------|-------|---------|-----------|
| `idx_cm_concept_video` | `concept_mentions` | `(concept_id, video_id)` | Knowledge context API filters by concept_id IN list + neq video_id |
| `idx_cm_mention_type_quality` | `concept_mentions` | `(concept_id, mention_type, explanation_quality DESC)` | explain_differently tool orders by explanation_quality |
| `idx_cvl_source_confidence` | `cross_video_links` | `(source_video_id, confidence DESC)` | Knowledge context API orders by confidence |
| `idx_vm_video_timestamp` | `video_moments` | `(video_id, timestamp_seconds)` | get_chapter_context tool does timestamp range scan |
| `idx_vm_video_importance` | `video_moments` | `(video_id, importance DESC)` | build_context_block orders by importance |
| `idx_vc_video_start` | `video_chapters` | `(video_id, start_seconds)` | get_chapter_context tool does lte range scan |
| `idx_qq_video_difficulty` | `quiz_questions` | `(video_id, difficulty)` | get_quiz tool filters by difficulty |
| `idx_qq_video_bloom` | `quiz_questions` | `(video_id, bloom_level)` | get_quiz tool filters by bloom_level |
| `idx_bp_status` | `batch_progress` | `(status)` | Batch extraction script filters by status |
| `idx_concepts_domain` | `concepts` | GIN `(domain)` | Future: filtering concepts by domain |
| `idx_vk_title_trgm` | `video_knowledge` | GIN trigram on `title` | search_knowledge tool does ilike on title |

### Performance Issues Not Addressed (system queries)

| Query | Reason |
|-------|--------|
| `SELECT name FROM pg_timezone_names` (0.42s, 26 calls) | Supabase internal query, cannot optimize |
| `CONCURRENTLY` index creation (0.75s, 1 call) | One-time migration operation |
| `pg_backup_start` / `pg_available_extensions` | System maintenance queries |

### Existing Indexes Retained (no changes needed)

- `conversations`: `conversations_updated_at_idx` (updated_at DESC)
- `transcripts`: `transcripts_expires_at_idx` (expires_at) -- TTL cleanup
- `video_sessions`: `video_sessions_video_id_idx`, `video_sessions_updated_at_idx`
- `video_knowledge`: `idx_vk_channel`, `idx_vk_topics` (GIN)
- `concepts`: `idx_concepts_display_trgm` (GIN trigram), `idx_concepts_category`, `idx_concepts_embedding` (ivfflat)
- `knowledge_embeddings`: `idx_ke_entity`, `idx_ke_video`, `idx_ke_embedding` (ivfflat)
- All single-column indexes on FK columns

---

## Impact Assessment

### Application Compatibility

**No breaking changes for the deployed application.** All server-side API routes already use the service role key via `getAdminClient()` or `getWriteClient()`, which bypasses RLS entirely. The only client-side write path (`conversations.ts`) retains open write access.

### Migration Safety

- All `DROP POLICY IF EXISTS` guards prevent errors on re-run
- All `CREATE INDEX IF NOT EXISTS` guards prevent duplicate indexes
- Extension moves use `DO $$ ... EXCEPTION` blocks for graceful failure
- `CREATE OR REPLACE FUNCTION` is inherently idempotent
- `CREATE OR REPLACE VIEW` is inherently idempotent
- Final `NOTIFY pgrst, 'reload schema'` ensures PostgREST picks up changes

### Rollback Plan

If issues arise, each section can be individually reverted:

1. **RLS on voice_clones:** Cannot be disabled without dropping policies first
2. **View:** `CREATE OR REPLACE VIEW video_embeddings AS ...` (remove `security_invoker`)
3. **Functions:** Redeploy original function definitions without `SET search_path`
4. **Extensions:** `ALTER EXTENSION pg_trgm SET SCHEMA public` (reverse the move)
5. **Policies:** Drop new policies, recreate old `FOR ALL USING (true) WITH CHECK (true)` policies
6. **Indexes:** `DROP INDEX IF EXISTS <index_name>` for each new index
